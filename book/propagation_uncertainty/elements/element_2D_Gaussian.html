<!DOCTYPE html>
<html>
  <head>
    <meta name="Effect of correlation">
    <title>2D Gaussian inference</title>
    <script src="https://unpkg.com/mathjs/lib/browser/math.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pca-js@1.0.0/pca.min.js"></script>
  </head>
  <!-- Create a div where the graph will take place -->
  <div id="my_dataviz">
  
    <svg id="click" xmlns="http://www.w3.org/2000/svg">
    </svg>
    
    <input type="range" min="-100" max="100" value="70" class="slider" id="slider_correlation">
    <input type="range" min="-200" max="200" value="0" class="slidermu" id="slider_mu1">
    <input type="range" min="0" max="150" value="100" class="slidersd" id="slider_sd1">
    <input type="range" min="-200" max="200" value="0" class="slidermu" id="slider_mu2">
    <input type="range" min="0" max="150" value="100" class="slidersd" id="slider_sd2">
    
  </div>
  
    <style>
      body{
          margin: 0; overflow: hidden;
          font-family: Helvetica, sans-serif;
        }
      .my_datavizdiv {
          position: absolute;
      }
      svg {
        position: absolute;
        top: 0;
        left: 0;
        background-color: None
      }
      #myDropdown { 
        position: absolute; 
        top: 0; 
        left: 0; 
        font-family: Helvetica, sans-serif;
      }
      .slider {
        position: absolute;
      }
      .slidermu {
        position: absolute;
        accent-color: #3f9b0b
      }
      .slidersd {
        position: absolute;
        accent-color: #ff5000
      }
      #sliderValue {
        display: block;
        text-align: center;
        margin-top: 10px;
        font-weight: bold;
      }

    </style>
  
  <!-- Create a div where the graph will take place -->
  <body>
    <script>
      // ===================================================
      // Set up basic viewport options
      // ===================================================
      
      // Get the viewport height and width
      const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)
      const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)

			var height  	= vh;
      var width 		= vw;
      
      const aspect 	= 3;
      
      if (vw/aspect < vh) {
      	// Viewport width is limiting
        var width 	= vw;
        var height 	= vw/aspect;
      } else {
      	// Viewport height is limiting
      	var width 	= vh*aspect;
        var height 	= vh;
      }

      // Create the canvas. We will use only part of it for the main plot
      var svg = d3.select("#click") // This selects the div
          .attr("width", width) // This defines the canvas' width
          .attr("height", height) // This defines the canvas' height
          
  
         
      
      var correlation = 0.7;
      var sigma_x = 1;
      var sigma_y = 1;
      
      var mu = [0, 0];
      var cov = [
        [sigma_x*sigma_x, sigma_x*sigma_y*correlation],
        [sigma_y*sigma_x*correlation, sigma_y*sigma_y]
      ];

      const color_prior = "#fac205";
      const color_likelihood = "#0485d1";
      const color_observation = "#3f9b0b";
      const color_posterior = "#f43605" //"#02c14d";
      var xrange = [-3, 3];
      var yrange = [-3, 3];
      x_limits = xrange
      y_limits = yrange
      window_left_x = [width * 0.05, width * 0.05 + height*0.7 ];
      window_left_y = [height * 0.1, height * 0.8];
      
      // Get scaling functions for the x scale and the y_scale
      const xScale_left = d3.scaleLinear().domain([x_limits[0], x_limits[1]]).range(window_left_x)
      const xScale_inverse_left = d3.scaleLinear().domain(window_left_x).range([x_limits[0], x_limits[1]])
      const yScale_left = d3.scaleLinear().domain([y_limits[0], y_limits[1]]).range([window_left_y[1], window_left_y[0]])
      
      // Add title
      svg.append("text")
      	.attr("transform", "translate(" + (math.mean(window_left_x)).toString() + "," + (height * 0.05).toString() + ")")
        .style("text-anchor", "middle")
        .text("density contours")
        .style("font-size", (12 * width / 600).toString() + "px")
      
      // Draw the x axis
      svg.append("g")
      	.attr("transform", "translate(0," + window_left_y[1].toString() + ")")
        .call(d3.axisBottom(xScale_left).ticks(7))
        .style("font-size", (12 * width / 600).toString() + "px")
      svg.append("text")
      	.attr("transform", "translate(" + (math.mean(window_left_x)).toString() + "," + (height * 0.95).toString() + ")")
        .style("text-anchor", "middle")
        .text("X1")
        .style("font-size", (12 * width / 600).toString() + "px")
      
      // Draw the y axis
      svg.append("g")
      	.attr("transform", "translate(" + (window_left_x[0]).toString() + ",0)")
        .attr("id", "mainxaxis")
        .call(d3.axisLeft(yScale_left).ticks(7))
        .style("font-size", (12 * width / 600).toString() + "px");
      svg.append("text")
      	.attr("transform", "translate(" + (width * 0.02).toString() + "," + (math.mean(window_left_y)).toString() + ") rotate(270)")
        .style("text-anchor", "middle")
        .text("X2")
        .style("font-size", (12 * width / 600).toString() + "px");

      

      
      
      
      // Create the second subplot
      
			window_right_x = [width * 0.38, width * 0.38 + height*0.7 ];
      window_right_y = [height * 0.1, height * 0.8];
      
      // Get scaling functions for the x scale and the y_scale
      const xScale_right = d3.scaleLinear().domain([x_limits[0], x_limits[1]]).range(window_right_x)
      const xScale_inverse_right = d3.scaleLinear().domain(window_right_x).range([x_limits[0], x_limits[1]])
      const yScale_right = d3.scaleLinear().domain([y_limits[0], y_limits[1]]).range([window_right_y[1], window_right_y[0]])
      
      // Add title
      svg.append("text")
      	.attr("transform", "translate(" + (math.mean(window_right_x)).toString() + "," + (height * 0.05).toString() + ")")
        .style("text-anchor", "middle")
        .text("samples")
        .style("font-size", (12 * width / 600).toString() + "px")
      
      // Draw the x axis
      svg.append("g")
      	.attr("transform", "translate(0," + window_right_y[1].toString() + ")")
        .call(d3.axisBottom(xScale_right).ticks(7))
        .style("font-size", (12 * width / 600).toString() + "px")
      svg.append("text")
      	.attr("transform", "translate(" + (math.mean(window_right_x)).toString() + "," + (height * 0.95).toString() + ")")
        .style("text-anchor", "middle")
        .text("X1")
        .style("font-size", (12 * width / 600).toString() + "px")
      
      // Draw the y axis
      svg.append("g")
      	.attr("transform", "translate(" + (window_right_x[0]).toString() + ",0)")
        .attr("id", "mainxaxis")
        .call(d3.axisLeft(yScale_right).ticks(7))
        .style("font-size", (12 * width / 600).toString() + "px");
      svg.append("text")
      	.attr("transform", "translate(" + (width * 0.35).toString() + "," + (math.mean(window_right_y)).toString() + ") rotate(270)")
        .style("text-anchor", "middle")
        .text("X2")
        .style("font-size", (12 * width / 600).toString() + "px");
      
      
      // Draw 250 standard Gaussian samples
      samples = [];
      for (i = 0; i < 250; i++) {
      	samples.push([gaussianRandom(),gaussianRandom()])
        
        svg.append("circle")
          .attr("cx",xScale_right(samples[i][0]))
          .attr("cy",yScale_right(samples[i][1]))
          .attr("r",height*0.005)
          .style("fill","#666")
          .style("stroke","None")
          .attr("id","scatter"+i.toString())
          .attr("class","scatter")
          .lower()
        
      }
      
      scatter_samples()
      
      
      // ======================================================
      // Place sliders
      // ======================================================
      
			// Place the slider
      var height_offset = height*0.05
      
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.825).toString() + "," + (height_offset+height*0.025).toString() + ")")
        .style("text-anchor", "middle")
        .text("correlation")
        .style("font-size", (12 * width / 600).toString() + "px")
      document.getElementById('slider_correlation').style.left = (width*0.675).toString()+"px";
      document.getElementById('slider_correlation').style.top = (height_offset + height*0.025).toString()+"px";
      document.getElementById('slider_correlation').style.width = (width*0.3).toString()+"px";
      document.getElementById('slider_correlation').style.height = (height*0.05).toString()+"px";
      document.getElementById('slider_correlation').style.fontSize = (16*width/600).toString()+"px";
      const slider = document.getElementById("slider_correlation");
      slider.addEventListener("input", function() {
      	correlation = parseInt(this.value)/100;
        update()
      });
      
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.675).toString() + "," + (height * 0.15 + height_offset).toString() + ")")
        .style("text-anchor", "left")
        .text("-1")
        .style("font-size", (12 * width / 600).toString() + "px")
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.955).toString() + "," + (height * 0.15 + height_offset).toString() + ")")
        .style("text-anchor", "right")
        .text("+1")
        .style("font-size", (12 * width / 600).toString() + "px")
      
      
      
			// Place the slider
      var height_offset = height*0.25
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.825).toString() + "," + (height_offset+height*0.025).toString() + ")")
        .style("text-anchor", "middle")
        .text("mean of X1")
        .style("font-size", (12 * width / 600).toString() + "px")
      document.getElementById('slider_mu1').style.left = (width*0.675).toString()+"px";
      document.getElementById('slider_mu1').style.top = (height_offset + height*0.025).toString()+"px";
      document.getElementById('slider_mu1').style.width = (width*0.3).toString()+"px";
      document.getElementById('slider_mu1').style.height = (height*0.05).toString()+"px";
      document.getElementById('slider_mu1').style.fontSize = (16*width/600).toString()+"px";
      const slidermu1 = document.getElementById("slider_mu1");
      slidermu1.addEventListener("input", function() {
      	mu[0] = parseInt(this.value)/100;
        update()
      });
      
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.675).toString() + "," + (height * 0.15 + height_offset).toString() + ")")
        .style("text-anchor", "left")
        .text("-2")
        .style("font-size", (12 * width / 600).toString() + "px")
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.955).toString() + "," + (height * 0.15 + height_offset).toString() + ")")
        .style("text-anchor", "right")
        .text("+2")
        .style("font-size", (12 * width / 600).toString() + "px")
      
      
      

			// Place the slider
      var height_offset = height*0.45
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.825).toString() + "," + (height_offset+height*0.025).toString() + ")")
        .style("text-anchor", "middle")
        .text("standard deviation of X1")
        .style("font-size", (12 * width / 600).toString() + "px")
      document.getElementById('slider_sd1').style.left = (width*0.675).toString()+"px";
      document.getElementById('slider_sd1').style.top = (height_offset + height*0.025).toString()+"px";
      document.getElementById('slider_sd1').style.width = (width*0.3).toString()+"px";
      document.getElementById('slider_sd1').style.height = (height*0.05).toString()+"px";
      document.getElementById('slider_sd1').style.fontSize = (16*width/600).toString()+"px";
      const slider2 = document.getElementById("slider_sd1");
      slider2.addEventListener("input", function() {
      	sigma_x = parseInt(this.value)/100;
        update()
      });
      
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.675).toString() + "," + (height * 0.15 + height_offset).toString() + ")")
        .style("text-anchor", "left")
        .text("0")
        .style("font-size", (12 * width / 600).toString() + "px")
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.8675).toString() + "," + (height * 0.15 + height_offset).toString() + ")")
        .style("text-anchor", "right")
        .text("1")
        .style("font-size", (12 * width / 600).toString() + "px")
      
      
			// Place the slider
      var height_offset = height*0.65
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.825).toString() + "," + (height_offset+height*0.025).toString() + ")")
        .style("text-anchor", "middle")
        .text("mean of X2")
        .style("font-size", (12 * width / 600).toString() + "px")
      document.getElementById('slider_mu2').style.left = (width*0.675).toString()+"px";
      document.getElementById('slider_mu2').style.top = (height_offset + height*0.025).toString()+"px";
      document.getElementById('slider_mu2').style.width = (width*0.3).toString()+"px";
      document.getElementById('slider_mu2').style.height = (height*0.05).toString()+"px";
      document.getElementById('slider_mu2').style.fontSize = (16*width/600).toString()+"px";
      const slidermu2 = document.getElementById("slider_mu2");
      slidermu2.addEventListener("input", function() {
      	mu[1] = parseInt(this.value)/100;
        update()
      });
      
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.675).toString() + "," + (height * 0.15 + height_offset).toString() + ")")
        .style("text-anchor", "left")
        .text("-2")
        .style("font-size", (12 * width / 600).toString() + "px")
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.955).toString() + "," + (height * 0.15 + height_offset).toString() + ")")
        .style("text-anchor", "right")
        .text("+2")
        .style("font-size", (12 * width / 600).toString() + "px")
      
      
      
      
      
      
      			// Place the slider
      var height_offset = height*0.85
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.825).toString() + "," + (height_offset+height*0.025).toString() + ")")
        .style("text-anchor", "middle")
        .text("standard deviation of X2")
        .style("font-size", (12 * width / 600).toString() + "px")
      document.getElementById('slider_sd2').style.left = (width*0.675).toString()+"px";
      document.getElementById('slider_sd2').style.top = (height_offset + height*0.025).toString()+"px";
      document.getElementById('slider_sd2').style.width = (width*0.3).toString()+"px";
      document.getElementById('slider_sd2').style.height = (height*0.05).toString()+"px";
      document.getElementById('slider_sd2').style.fontSize = (16*width/600).toString()+"px";
      const slider3 = document.getElementById("slider_sd2");
      slider3.addEventListener("input", function() {
      	sigma_y = parseInt(this.value)/100;
        update()
      });
      
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.675).toString() + "," + (height * 0.15 + height_offset).toString() + ")")
        .style("text-anchor", "left")
        .text("0")
        .style("font-size", (12 * width / 600).toString() + "px")
      svg.append("text")
        .attr("transform", "translate(" + (width * 0.8675).toString() + "," + (height * 0.15 + height_offset).toString() + ")")
        .style("text-anchor", "right")
        .text("1")
        .style("font-size", (12 * width / 600).toString() + "px")


      // Draw the new contours
      update()
      
      
      // ======================================================
      // Define functions
      // ======================================================

 
        
        
        function scatter_samples() {
        
        	// Transform the samples
          var samples_transformed = transform_standard_Gaussian_samples(samples,correlation)
        
          for (i = 0; i < 250; i++) {
          
            d3.select("#scatter"+i.toString())
              .attr("cx",xScale_right(samples_transformed[i][0] + mu[0]))
              .attr("cy",yScale_right(samples_transformed[i][1] + mu[1]))

          }
        
        }


        function draw_contours(mu, cov) {
        	
          // Delete all previous contour lines
          svg.selectAll(".contour_lines").remove();
          
          // Do a principal component analysis of the covariance matrix
          vectors = PCA.computeSVD(cov);
          
          // Get quantiles
          sds = [2.29742059, 1.75524714, 1.43500483, 1.17741105, 0.94003483,
            0.69449473, 0.38498817
          ];
          
          colors = ['#4146ac', '#3aa3fc', '#25eca7', '#a4fc3c', '#f4c73a', '#f36315', '#b21a01'];
          for (j = 0; j < 7; j++) {
            sd = sds[j] * math.sqrt(vectors[0]["eigenvalue"]);
            svg.append("ellipse") // attach an ellipse
              .attr("cx", 0)
              .attr("cy", 0)
              .attr("rx", 0.7 * height / 6 * sd)
              .attr("ry", 0.7 * height / 6 * math.sqrt(vectors[1]["eigenvalue"]) / math.sqrt(vectors[0]["eigenvalue"]) * sd)
              .attr("transform", "translate(" + (xScale_left(mu[0])).toString() + "," + (yScale_left(mu[1])).toString() + ") rotate(" + (-math.atan2(vectors[0]["vector"][1], vectors[0]["vector"][0]) / math.pi * 180).toString() + ")")
              .attr("fill", "None")
              .attr("stroke", colors[j])
              .attr("stroke-linejoin", "round")
              .attr('stroke-width', 1 * width / 500)
              .attr("class", "contour_lines")
              .lower();
          }
        }



				var local_correlation,local_sigma_x,local_sigma_y

        function update() {
        
          // Update covariance
          correlation = math.min([0.9999999,math.max([-0.9999999,correlation])])
          sigma_x = math.max([0.01,sigma_x])
          sigma_y = math.max([0.01,sigma_y])
          
          // Update covariance
          cov = [
            [sigma_x*sigma_x, sigma_x*sigma_y*correlation],
            [sigma_y*sigma_x*correlation, sigma_y*sigma_y]
          ];
          
          // Update the plots
          draw_contours(mu, cov)
          scatter_samples()
          
          
        }
        
        
        
        
        // Standard Normal variate using Box-Muller transform.
        function gaussianRandom(mean=0, stdev=1) {
            const u = 1 - Math.random(); // Converting [0,1) to (0,1]
            const v = Math.random();
            const z = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
            // Transform to the desired mean and standard deviation:
            return z * stdev + mean;
        }
        
        
        function transform_standard_Gaussian_samples(samples) {
        
        	var cholesky = [[sigma_x,0],[sigma_y*correlation,sigma_y*math.sqrt(1-math.pow(correlation,2))]];
        
        	return math.transpose(math.multiply(cholesky,math.transpose(samples)))
        	
        }


        var deltaX, deltaY
        var dragHandler = d3.drag().on("start", function() {
          var current = d3.select(this);
          deltaX = current.attr("x") - d3.event.x;
          deltaY = current.attr("y") - d3.event.y;
        }).on("drag", function() {
          var movex = d3.event.x + deltaX;
          var movey = d3.event.y + deltaY;
          var current = d3.select(this);
          // Limit movex, if necessary
          if (movex < window_x[0]) {
            movex = window_x[0];
          } else if (movex > window_x[1]) {
            movex = window_x[1];
          }
          // Limit movey, if necessary
          if (movey < window_y[0]) {
            movey = window_y[0];
          } else if (movey > window_y[1]) {
            movey = window_y[1];
          }
          current.attr("x", movex);
          d3.select("#observation_line").attr("x1", movex).attr("x2", movex);
          d3.select("#observation_circle").attr("cx", movex)
          d3.select("#observation_circle_center").attr("cx", movex)
          d3.select("#observation_label").attr("transform", "translate(" + (movex + width * 0.015).toString() + "," + (height * 0.695).toString() + ")");
          prop = pixels_to_values(movex, "x");
          observation = prop;
          update()
        })
        dragHandler(svg.selectAll("use"));
    </script>
  </body>
</html>